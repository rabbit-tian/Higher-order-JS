### 数据类型
1. 基本数据类型
    -  Number
    -  String
    -  Boolean
    -  Undefined
    -  Null
    -  Symbol（ES6）
    
2. 引用数据类型
    - Object
        - Array
        - Function
        - Date
        - Math
        - RegExp
        
### 每种类型的值
1. Number
    - 数字（浮点数和整数）
2. String
    - 一对单引号或双引号或反引号包含的字符
    - ‘’   “”   ``
3. Boolean
    - true
    - false
4. Undefined  
    - Undefined
5. Null
    - Null
6. Object
    - {} 普通的对象
7. 定义值
    - 构造函数 => new 构造函数 let arr = new Array()
        - 以下是内置对象
        - Number
        - String
        - Boolean
        - Object
        - Array
        - Function
        - Date
        - RegExp
        - Math（没有构造函数）
    - 字面量
        - let arr = []
        - let obj = {}
        
### 数据类型转换
1. 把一种类型转为另一种类型
2. 转成Number 简写 +
    - Number() => 必须给的字符串是纯数字才能转换成功，否则返回NaN
    - parseInt() => 整数 提取数字部分 ‘12px’ 
    - parseFloat() => 小数
3. 转成String 简写 ‘’
    - String()
    - toString()  直接 3.toString() 会解析成小数
        - (3).toString()
        - 3..toString()
        - 3 .toString()
        - [1,2,3].toString() => 
        - {a:1}.toString()  => {object Object}   
4. 转成Boolean  简写 ！！
    - Boolean()
5. 特性
    - NaN： not a number
        - 和任何值都不相同，包括自己
        - 和任何值 比较 都返回 false 
        - 和任何值 计算 都返回 NaN
        - isNaN 可以区分NaN  isNaN(1) => false       
    
### 隐式类型转换
1. 解析会自动把一种类型装换成另一种类型，便于操作
2. if(1<2)
3. 1<2
4. '1' - 1 => 0
5. ==
6. +  字符串拼接   加法

### 检测值的类型
1. typeof

### 运算符
1. 算数运算符 ： + - * / %
2. 赋值： =  +=  -=  *=  /=  === !==
    - == 会把两边转成相同类型，再比较
    - === 先判断类型想不相同
3. 逻辑运算符
    - &&
         - 如果左边为真，就返回右边的值  a = 1&&2  => 2
         - a = 1 && 1>2   => false
    - ||
        - 只要一个为真，就为真
        - a = 1 || 1>2  => 1
        - b = 0 || false => false
        - b = 0 || 0  => 后面那个0
4. 三元运算符（条件运算符）   条件？ 值：值
    - let a = 1 < 2 ? '成立'：'不成立'
5. 一元运算符：自增  自减  new  typeof  delete
    - 自增：let a = 1  a++ 不能写1++   必须用在变量身上


### 函数
1. 可执行的对象，作用：把多行代码块封装在函数中，可复用
2. 函数的定义
    - 函数的声明
        `  function fn () {}`
    - 函数表达式：把函数作为一个值，给变量
        `let fn = function () {}`
        - 函数可以没有名字
        - 加入函数有了名字，只能在内部使用 =>  应用场景：递归
3. 函数的调用
    - 直接调用  函数名()
    - 匿名函数的数调用方法：把匿名函数包起来，表明是一个完整的值
        - `(function (){})()`
        - `!function (){}()`
        - `+function (){}()`
    - call调用,apply调用
        - fn.call()  第一个参数为null或undefined时，this指向window
    - 定时器调用
    - 事件调用
    - new操作符 调用
    - 对象调用
4. 函数的返回值
    - 函数调用后都有返回值
    - 默认undefined
    - return 返回   是操作符
        - 结束函数的执行
    - break： 结束for循环的执行
5. 函数的参数
    - 形参  定义时写
    - 
    - 实参  调用时传入
6. 函数中arguments   => 类数组  实参的集合 变量
    - 实参不确定几个，用arguments接收实参
    - 数组和类数组
        - 共同的地方
            - 结构相同
            - 都有length
            - 使用下标取值
        - 不同地方
            - 类数组没有数组的方法  splice  push等方法
6. 函数中的this
    - 函数在定义的时候都会有一个内置的  变量
    - 函数调用的时候确定
        - 直接调用  => window
        - 匿名函数调用  => window
        - call调用,apply调用
        - 定时器 => window
        - 事件调用  => 触发事件的元素
        - new  => 函数内部创建的对象 （实例）
        - 对象调用 => 对象调用的函数
7. 函数作用域和作用域链
    - 标识符：函数名，变量名
    - 作用域：标识符可以访问的范围，标识符可以起作用的范围
        - 全局范围
        - 局部（函数）范围：能够划分作用域就是函数
    - 作用域链
        - 保证了访问标识符的顺序
    - 闭包
        - 函数有权访问另一个函数作用域变量，就形成了闭包
        - 动态作用域：根据函数的调用位置不同，找函数调用位置的作用的变量
        - 静态作用域：函数定义的时候已经确定了作用域的位置
        
        ```javascript
            function fn(){
                var a = 10
                function fn2(){
                    a++
                }
                return fn2
            }
            
            let f = fn()
            f(); // 一直执行fn2，fn只执行了一次
           
        ```


### 包装对象
1. 简单类型 不是对象类型，没有属性和方法
2. 内置有包装对象的方法，把简单类型包装成对象，再调用方法
3. 每次包装对象调用后，就销毁此包装对象
1. String
2. Boolean
3. Number

